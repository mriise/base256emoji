use std::fmt;

#[derive(Debug, Clone)]
pub struct DecodeError {
	codepoint: char,
	index: usize,
}

impl fmt::Display for DecodeError {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"{} at index {} is not part of the alphabet",
			self.codepoint, self.index
		)
	}
}

pub type Alphabet = [char; 256];

pub trait Base {
	const ALPHABET: Alphabet;

	fn decode(input: &str) -> Result<Vec<u8>, DecodeError> {
		let s = input.chars().count();
		let mut output = vec!(0u8; s);
		for (i, c) in input.chars().enumerate() {
			output[i] = match Self::ALPHABET.iter().position(|&x| x == c) {
				Some(c) => c.try_into().unwrap(),
				None => {
					return Err(DecodeError {
						codepoint: c,
						index: i,
					});
				}
			};
		}

		Ok(output)
	}

	fn encode(input: &Vec<u8>) -> String {
		let s = input
			.iter()
			.map(|&x| Self::ALPHABET[x as usize].len_utf8())
			.sum();
		let mut output: Vec<u8> = vec!(0; s);
		let mut i = 0;
		for &v in input.iter() {
			let c = Self::ALPHABET[v as usize];
			c.encode_utf8(&mut output[i..]);
			i += c.len_utf8();
		}

		String::from_utf8(output).unwrap()
	}
}

#[derive(Debug, Default)]
pub struct Emoji;

impl Base for Emoji {
	const ALPHABET: Alphabet = [
		'ðŸš€', 'ðŸª', 'â˜„', 'ðŸ›°', 'ðŸŒŒ', 'ðŸŒ‘', 'ðŸŒ’', 'ðŸŒ“', 'ðŸŒ”', 'ðŸŒ•', 'ðŸŒ–', 'ðŸŒ—', 'ðŸŒ˜', 'ðŸŒ', 'ðŸŒ',
		'ðŸŒŽ', 'ðŸ‰', 'â˜€', 'ðŸ’»', 'ðŸ–¥', 'ðŸ’¾', 'ðŸ’¿', 'ðŸ˜‚', 'â¤', 'ðŸ˜', 'ðŸ¤£', 'ðŸ˜Š', 'ðŸ™', 'ðŸ’•', 'ðŸ˜­',
		'ðŸ˜˜', 'ðŸ‘', 'ðŸ˜…', 'ðŸ‘', 'ðŸ˜', 'ðŸ”¥', 'ðŸ¥°', 'ðŸ’”', 'ðŸ’–', 'ðŸ’™', 'ðŸ˜¢', 'ðŸ¤”', 'ðŸ˜†', 'ðŸ™„', 'ðŸ’ª',
		'ðŸ˜‰', 'â˜º', 'ðŸ‘Œ', 'ðŸ¤—', 'ðŸ’œ', 'ðŸ˜”', 'ðŸ˜Ž', 'ðŸ˜‡', 'ðŸŒ¹', 'ðŸ¤¦', 'ðŸŽ‰', 'ðŸ’ž', 'âœŒ', 'âœ¨', 'ðŸ¤·',
		'ðŸ˜±', 'ðŸ˜Œ', 'ðŸŒ¸', 'ðŸ™Œ', 'ðŸ˜‹', 'ðŸ’—', 'ðŸ’š', 'ðŸ˜', 'ðŸ’›', 'ðŸ™‚', 'ðŸ’“', 'ðŸ¤©', 'ðŸ˜„', 'ðŸ˜€', 'ðŸ–¤',
		'ðŸ˜ƒ', 'ðŸ’¯', 'ðŸ™ˆ', 'ðŸ‘‡', 'ðŸŽ¶', 'ðŸ˜’', 'ðŸ¤­', 'â£', 'ðŸ˜œ', 'ðŸ’‹', 'ðŸ‘€', 'ðŸ˜ª', 'ðŸ˜‘', 'ðŸ’¥', 'ðŸ™‹',
		'ðŸ˜ž', 'ðŸ˜©', 'ðŸ˜¡', 'ðŸ¤ª', 'ðŸ‘Š', 'ðŸ¥³', 'ðŸ˜¥', 'ðŸ¤¤', 'ðŸ‘‰', 'ðŸ’ƒ', 'ðŸ˜³', 'âœ‹', 'ðŸ˜š', 'ðŸ˜', 'ðŸ˜´',
		'ðŸŒŸ', 'ðŸ˜¬', 'ðŸ™ƒ', 'ðŸ€', 'ðŸŒ·', 'ðŸ˜»', 'ðŸ˜“', 'â­', 'âœ…', 'ðŸ¥º', 'ðŸŒˆ', 'ðŸ˜ˆ', 'ðŸ¤˜', 'ðŸ’¦', 'âœ”',
		'ðŸ˜£', 'ðŸƒ', 'ðŸ’', 'â˜¹', 'ðŸŽŠ', 'ðŸ’˜', 'ðŸ˜ ', 'â˜', 'ðŸ˜•', 'ðŸŒº', 'ðŸŽ‚', 'ðŸŒ»', 'ðŸ˜', 'ðŸ–•', 'ðŸ’',
		'ðŸ™Š', 'ðŸ˜¹', 'ðŸ—£', 'ðŸ’«', 'ðŸ’€', 'ðŸ‘‘', 'ðŸŽµ', 'ðŸ¤ž', 'ðŸ˜›', 'ðŸ”´', 'ðŸ˜¤', 'ðŸŒ¼', 'ðŸ˜«', 'âš½', 'ðŸ¤™',
		'â˜•', 'ðŸ†', 'ðŸ¤«', 'ðŸ‘ˆ', 'ðŸ˜®', 'ðŸ™†', 'ðŸ»', 'ðŸƒ', 'ðŸ¶', 'ðŸ’', 'ðŸ˜²', 'ðŸŒ¿', 'ðŸ§¡', 'ðŸŽ', 'âš¡',
		'ðŸŒž', 'ðŸŽˆ', 'âŒ', 'âœŠ', 'ðŸ‘‹', 'ðŸ˜°', 'ðŸ¤¨', 'ðŸ˜¶', 'ðŸ¤', 'ðŸš¶', 'ðŸ’°', 'ðŸ“', 'ðŸ’¢', 'ðŸ¤Ÿ', 'ðŸ™',
		'ðŸš¨', 'ðŸ’¨', 'ðŸ¤¬', 'âœˆ', 'ðŸŽ€', 'ðŸº', 'ðŸ¤“', 'ðŸ˜™', 'ðŸ’Ÿ', 'ðŸŒ±', 'ðŸ˜–', 'ðŸ‘¶', 'ðŸ¥´', 'â–¶', 'âž¡',
		'â“', 'ðŸ’Ž', 'ðŸ’¸', 'â¬‡', 'ðŸ˜¨', 'ðŸŒš', 'ðŸ¦‹', 'ðŸ˜·', 'ðŸ•º', 'âš ', 'ðŸ™…', 'ðŸ˜Ÿ', 'ðŸ˜µ', 'ðŸ‘Ž', 'ðŸ¤²',
		'ðŸ¤ ', 'ðŸ¤§', 'ðŸ“Œ', 'ðŸ”µ', 'ðŸ’…', 'ðŸ§', 'ðŸ¾', 'ðŸ’', 'ðŸ˜—', 'ðŸ¤‘', 'ðŸŒŠ', 'ðŸ¤¯', 'ðŸ·', 'â˜Ž', 'ðŸ’§',
		'ðŸ˜¯', 'ðŸ’†', 'ðŸ‘†', 'ðŸŽ¤', 'ðŸ™‡', 'ðŸ‘', 'â„', 'ðŸŒ´', 'ðŸ’£', 'ðŸ¸', 'ðŸ’Œ', 'ðŸ“', 'ðŸ¥€', 'ðŸ¤¢', 'ðŸ‘…',
		'ðŸ’¡', 'ðŸ’©', 'ðŸ‘', 'ðŸ“¸', 'ðŸ‘»', 'ðŸ¤', 'ðŸ¤®', 'ðŸŽ¼', 'ðŸ¥µ', 'ðŸš©', 'ðŸŽ', 'ðŸŠ', 'ðŸ‘¼', 'ðŸ’', 'ðŸ“£',
		'ðŸ¥‚',
	];
}

#[cfg(test)]
mod tests {
	use crate::Base;
	use crate::Emoji;

	#[test]
	fn byte1_rt() {
		let mut org = vec!(0u8; 1);
		for i in 0..255 {
			org[0] = i;
			let r = match Emoji::decode(Emoji::encode(&org).as_str()) {
				Ok(x) => x,
				Err(e) => {
					panic!("{}", e);
				}
			};
			assert_eq!(org, r)
		}
	}
}
