#![recursion_limit = "256"]
use std::fmt;

use heapless::FnvIndexMap;

#[derive(Debug, Clone)]
pub struct DecodeError {
	codepoint: char,
	index: usize,
}

impl fmt::Display for DecodeError {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		write!(
			f,
			"{} at index {} is not part of the alphabet",
			self.codepoint, self.index
		)
	}
}

pub type Alphabet = [char; 256];

pub trait Base: Default {
	const ALPHABET: Alphabet;
	// should be moved to std oncecell at some point

	fn get_index(&self, c: char) -> Option<u8>;

	fn decode(&self, input: &str) -> Result<Vec<u8>, DecodeError> {
		let s = input.chars().count();
		let mut output = vec![0; s];
		for (i, c) in input.chars().enumerate() {
			output[i] = Self::get_index(self, c).ok_or(DecodeError {
				codepoint: c,
				index: i,
			})?;
		}

		Ok(output)
	}

	fn encode(&self, input: &Vec<u8>) -> String {
		let s = input
			.iter()
			.map(|&x| Self::ALPHABET[x as usize].len_utf8())
			.sum();
		let mut output: Vec<u8> = vec![0; s];
		let mut i = 0;
		for &v in input.iter() {
			let c = Self::ALPHABET[v as usize];
			c.encode_utf8(&mut output[i..]);
			i += c.len_utf8();
		}

		String::from_utf8(output).unwrap()
	}
}

#[derive(Debug)]
pub struct Emoji {
	lookup: FnvIndexMap<char, u8, 256>
}

#[derive(Debug, Default)]
pub struct EmojiE;

#[derive(Debug, Default)]
pub struct EmojiM;

impl Default for Emoji {
    fn default() -> Self {
		let mut lookup = FnvIndexMap::new();

		for (i, &c) in Self::ALPHABET.iter().enumerate() {
			lookup.insert(c, i as u8).unwrap();
		}

        Self { lookup }
    }
}

impl Base for Emoji {
	const ALPHABET: Alphabet = [
		'ðŸš€', 'ðŸª', 'â˜„', 'ðŸ›°', 'ðŸŒŒ', 'ðŸŒ‘', 'ðŸŒ’', 'ðŸŒ“', 'ðŸŒ”', 'ðŸŒ•', 'ðŸŒ–', 'ðŸŒ—', 'ðŸŒ˜', 'ðŸŒ', 'ðŸŒ',
		'ðŸŒŽ', 'ðŸ‰', 'â˜€', 'ðŸ’»', 'ðŸ–¥', 'ðŸ’¾', 'ðŸ’¿', 'ðŸ˜‚', 'â¤', 'ðŸ˜', 'ðŸ¤£', 'ðŸ˜Š', 'ðŸ™', 'ðŸ’•', 'ðŸ˜­',
		'ðŸ˜˜', 'ðŸ‘', 'ðŸ˜…', 'ðŸ‘', 'ðŸ˜', 'ðŸ”¥', 'ðŸ¥°', 'ðŸ’”', 'ðŸ’–', 'ðŸ’™', 'ðŸ˜¢', 'ðŸ¤”', 'ðŸ˜†', 'ðŸ™„',
		'ðŸ’ª', 'ðŸ˜‰', 'â˜º', 'ðŸ‘Œ', 'ðŸ¤—', 'ðŸ’œ', 'ðŸ˜”', 'ðŸ˜Ž', 'ðŸ˜‡', 'ðŸŒ¹', 'ðŸ¤¦', 'ðŸŽ‰', 'ðŸ’ž', 'âœŒ', 'âœ¨',
		'ðŸ¤·', 'ðŸ˜±', 'ðŸ˜Œ', 'ðŸŒ¸', 'ðŸ™Œ', 'ðŸ˜‹', 'ðŸ’—', 'ðŸ’š', 'ðŸ˜', 'ðŸ’›', 'ðŸ™‚', 'ðŸ’“', 'ðŸ¤©', 'ðŸ˜„',
		'ðŸ˜€', 'ðŸ–¤', 'ðŸ˜ƒ', 'ðŸ’¯', 'ðŸ™ˆ', 'ðŸ‘‡', 'ðŸŽ¶', 'ðŸ˜’', 'ðŸ¤­', 'â£', 'ðŸ˜œ', 'ðŸ’‹', 'ðŸ‘€', 'ðŸ˜ª',
		'ðŸ˜‘', 'ðŸ’¥', 'ðŸ™‹', 'ðŸ˜ž', 'ðŸ˜©', 'ðŸ˜¡', 'ðŸ¤ª', 'ðŸ‘Š', 'ðŸ¥³', 'ðŸ˜¥', 'ðŸ¤¤', 'ðŸ‘‰', 'ðŸ’ƒ', 'ðŸ˜³',
		'âœ‹', 'ðŸ˜š', 'ðŸ˜', 'ðŸ˜´', 'ðŸŒŸ', 'ðŸ˜¬', 'ðŸ™ƒ', 'ðŸ€', 'ðŸŒ·', 'ðŸ˜»', 'ðŸ˜“', 'â­', 'âœ…', 'ðŸ¥º',
		'ðŸŒˆ', 'ðŸ˜ˆ', 'ðŸ¤˜', 'ðŸ’¦', 'âœ”', 'ðŸ˜£', 'ðŸƒ', 'ðŸ’', 'â˜¹', 'ðŸŽŠ', 'ðŸ’˜', 'ðŸ˜ ', 'â˜', 'ðŸ˜•', 'ðŸŒº',
		'ðŸŽ‚', 'ðŸŒ»', 'ðŸ˜', 'ðŸ–•', 'ðŸ’', 'ðŸ™Š', 'ðŸ˜¹', 'ðŸ—£', 'ðŸ’«', 'ðŸ’€', 'ðŸ‘‘', 'ðŸŽµ', 'ðŸ¤ž', 'ðŸ˜›',
		'ðŸ”´', 'ðŸ˜¤', 'ðŸŒ¼', 'ðŸ˜«', 'âš½', 'ðŸ¤™', 'â˜•', 'ðŸ†', 'ðŸ¤«', 'ðŸ‘ˆ', 'ðŸ˜®', 'ðŸ™†', 'ðŸ»', 'ðŸƒ',
		'ðŸ¶', 'ðŸ’', 'ðŸ˜²', 'ðŸŒ¿', 'ðŸ§¡', 'ðŸŽ', 'âš¡', 'ðŸŒž', 'ðŸŽˆ', 'âŒ', 'âœŠ', 'ðŸ‘‹', 'ðŸ˜°', 'ðŸ¤¨',
		'ðŸ˜¶', 'ðŸ¤', 'ðŸš¶', 'ðŸ’°', 'ðŸ“', 'ðŸ’¢', 'ðŸ¤Ÿ', 'ðŸ™', 'ðŸš¨', 'ðŸ’¨', 'ðŸ¤¬', 'âœˆ', 'ðŸŽ€', 'ðŸº',
		'ðŸ¤“', 'ðŸ˜™', 'ðŸ’Ÿ', 'ðŸŒ±', 'ðŸ˜–', 'ðŸ‘¶', 'ðŸ¥´', 'â–¶', 'âž¡', 'â“', 'ðŸ’Ž', 'ðŸ’¸', 'â¬‡', 'ðŸ˜¨', 'ðŸŒš',
		'ðŸ¦‹', 'ðŸ˜·', 'ðŸ•º', 'âš ', 'ðŸ™…', 'ðŸ˜Ÿ', 'ðŸ˜µ', 'ðŸ‘Ž', 'ðŸ¤²', 'ðŸ¤ ', 'ðŸ¤§', 'ðŸ“Œ', 'ðŸ”µ', 'ðŸ’…',
		'ðŸ§', 'ðŸ¾', 'ðŸ’', 'ðŸ˜—', 'ðŸ¤‘', 'ðŸŒŠ', 'ðŸ¤¯', 'ðŸ·', 'â˜Ž', 'ðŸ’§', 'ðŸ˜¯', 'ðŸ’†', 'ðŸ‘†', 'ðŸŽ¤',
		'ðŸ™‡', 'ðŸ‘', 'â„', 'ðŸŒ´', 'ðŸ’£', 'ðŸ¸', 'ðŸ’Œ', 'ðŸ“', 'ðŸ¥€', 'ðŸ¤¢', 'ðŸ‘…', 'ðŸ’¡', 'ðŸ’©', 'ðŸ‘',
		'ðŸ“¸', 'ðŸ‘»', 'ðŸ¤', 'ðŸ¤®', 'ðŸŽ¼', 'ðŸ¥µ', 'ðŸš©', 'ðŸŽ', 'ðŸŠ', 'ðŸ‘¼', 'ðŸ’', 'ðŸ“£', 'ðŸ¥‚',
	];

	fn get_index(&self, c: char) -> Option<u8> {
		self.lookup.get(&c).copied()
	}
}

impl Base for EmojiE {
	const ALPHABET: Alphabet = [
		'ðŸš€', 'ðŸª', 'â˜„', 'ðŸ›°', 'ðŸŒŒ', 'ðŸŒ‘', 'ðŸŒ’', 'ðŸŒ“', 'ðŸŒ”', 'ðŸŒ•', 'ðŸŒ–', 'ðŸŒ—', 'ðŸŒ˜', 'ðŸŒ', 'ðŸŒ',
		'ðŸŒŽ', 'ðŸ‰', 'â˜€', 'ðŸ’»', 'ðŸ–¥', 'ðŸ’¾', 'ðŸ’¿', 'ðŸ˜‚', 'â¤', 'ðŸ˜', 'ðŸ¤£', 'ðŸ˜Š', 'ðŸ™', 'ðŸ’•', 'ðŸ˜­',
		'ðŸ˜˜', 'ðŸ‘', 'ðŸ˜…', 'ðŸ‘', 'ðŸ˜', 'ðŸ”¥', 'ðŸ¥°', 'ðŸ’”', 'ðŸ’–', 'ðŸ’™', 'ðŸ˜¢', 'ðŸ¤”', 'ðŸ˜†', 'ðŸ™„',
		'ðŸ’ª', 'ðŸ˜‰', 'â˜º', 'ðŸ‘Œ', 'ðŸ¤—', 'ðŸ’œ', 'ðŸ˜”', 'ðŸ˜Ž', 'ðŸ˜‡', 'ðŸŒ¹', 'ðŸ¤¦', 'ðŸŽ‰', 'ðŸ’ž', 'âœŒ', 'âœ¨',
		'ðŸ¤·', 'ðŸ˜±', 'ðŸ˜Œ', 'ðŸŒ¸', 'ðŸ™Œ', 'ðŸ˜‹', 'ðŸ’—', 'ðŸ’š', 'ðŸ˜', 'ðŸ’›', 'ðŸ™‚', 'ðŸ’“', 'ðŸ¤©', 'ðŸ˜„',
		'ðŸ˜€', 'ðŸ–¤', 'ðŸ˜ƒ', 'ðŸ’¯', 'ðŸ™ˆ', 'ðŸ‘‡', 'ðŸŽ¶', 'ðŸ˜’', 'ðŸ¤­', 'â£', 'ðŸ˜œ', 'ðŸ’‹', 'ðŸ‘€', 'ðŸ˜ª',
		'ðŸ˜‘', 'ðŸ’¥', 'ðŸ™‹', 'ðŸ˜ž', 'ðŸ˜©', 'ðŸ˜¡', 'ðŸ¤ª', 'ðŸ‘Š', 'ðŸ¥³', 'ðŸ˜¥', 'ðŸ¤¤', 'ðŸ‘‰', 'ðŸ’ƒ', 'ðŸ˜³',
		'âœ‹', 'ðŸ˜š', 'ðŸ˜', 'ðŸ˜´', 'ðŸŒŸ', 'ðŸ˜¬', 'ðŸ™ƒ', 'ðŸ€', 'ðŸŒ·', 'ðŸ˜»', 'ðŸ˜“', 'â­', 'âœ…', 'ðŸ¥º',
		'ðŸŒˆ', 'ðŸ˜ˆ', 'ðŸ¤˜', 'ðŸ’¦', 'âœ”', 'ðŸ˜£', 'ðŸƒ', 'ðŸ’', 'â˜¹', 'ðŸŽŠ', 'ðŸ’˜', 'ðŸ˜ ', 'â˜', 'ðŸ˜•', 'ðŸŒº',
		'ðŸŽ‚', 'ðŸŒ»', 'ðŸ˜', 'ðŸ–•', 'ðŸ’', 'ðŸ™Š', 'ðŸ˜¹', 'ðŸ—£', 'ðŸ’«', 'ðŸ’€', 'ðŸ‘‘', 'ðŸŽµ', 'ðŸ¤ž', 'ðŸ˜›',
		'ðŸ”´', 'ðŸ˜¤', 'ðŸŒ¼', 'ðŸ˜«', 'âš½', 'ðŸ¤™', 'â˜•', 'ðŸ†', 'ðŸ¤«', 'ðŸ‘ˆ', 'ðŸ˜®', 'ðŸ™†', 'ðŸ»', 'ðŸƒ',
		'ðŸ¶', 'ðŸ’', 'ðŸ˜²', 'ðŸŒ¿', 'ðŸ§¡', 'ðŸŽ', 'âš¡', 'ðŸŒž', 'ðŸŽˆ', 'âŒ', 'âœŠ', 'ðŸ‘‹', 'ðŸ˜°', 'ðŸ¤¨',
		'ðŸ˜¶', 'ðŸ¤', 'ðŸš¶', 'ðŸ’°', 'ðŸ“', 'ðŸ’¢', 'ðŸ¤Ÿ', 'ðŸ™', 'ðŸš¨', 'ðŸ’¨', 'ðŸ¤¬', 'âœˆ', 'ðŸŽ€', 'ðŸº',
		'ðŸ¤“', 'ðŸ˜™', 'ðŸ’Ÿ', 'ðŸŒ±', 'ðŸ˜–', 'ðŸ‘¶', 'ðŸ¥´', 'â–¶', 'âž¡', 'â“', 'ðŸ’Ž', 'ðŸ’¸', 'â¬‡', 'ðŸ˜¨', 'ðŸŒš',
		'ðŸ¦‹', 'ðŸ˜·', 'ðŸ•º', 'âš ', 'ðŸ™…', 'ðŸ˜Ÿ', 'ðŸ˜µ', 'ðŸ‘Ž', 'ðŸ¤²', 'ðŸ¤ ', 'ðŸ¤§', 'ðŸ“Œ', 'ðŸ”µ', 'ðŸ’…',
		'ðŸ§', 'ðŸ¾', 'ðŸ’', 'ðŸ˜—', 'ðŸ¤‘', 'ðŸŒŠ', 'ðŸ¤¯', 'ðŸ·', 'â˜Ž', 'ðŸ’§', 'ðŸ˜¯', 'ðŸ’†', 'ðŸ‘†', 'ðŸŽ¤',
		'ðŸ™‡', 'ðŸ‘', 'â„', 'ðŸŒ´', 'ðŸ’£', 'ðŸ¸', 'ðŸ’Œ', 'ðŸ“', 'ðŸ¥€', 'ðŸ¤¢', 'ðŸ‘…', 'ðŸ’¡', 'ðŸ’©', 'ðŸ‘',
		'ðŸ“¸', 'ðŸ‘»', 'ðŸ¤', 'ðŸ¤®', 'ðŸŽ¼', 'ðŸ¥µ', 'ðŸš©', 'ðŸŽ', 'ðŸŠ', 'ðŸ‘¼', 'ðŸ’', 'ðŸ“£', 'ðŸ¥‚',
	];

	fn get_index(&self, c: char) -> Option<u8> {
		Self::ALPHABET.iter().position(|&x| c == x).map(|c| c as u8)
	}
}

macro_rules! gen_alphabet {
	($name:ident, $alphabet:literal) => {
		impl Base for $name {
			const ALPHABET: [char; 256] = const_str::to_char_array!($alphabet);

			fn get_index(&self, c: char) -> Option<u8> {
				match_lookup::gen_char_match!(c, $alphabet).map(|c| c as u8)
			}
		}
	};
}

gen_alphabet!(EmojiM, "ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚");


#[cfg(test)]
mod tests {
	use crate::Base;
	use crate::Emoji;

	#[test]
	fn byte1_rt() {
		let mut org = vec![0u8; 1];
		for i in 0..255 {
			org[0] = i;
			let a = Emoji::default();
			let r = match a.decode(a.encode(&org).as_str()) {
				Ok(x) => x,
				Err(e) => {
					panic!("{}", e);
				}
			};
			assert_eq!(org, r)
		}
	}
}
